{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/SocialVerificationWebsite/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*\nThis service manages the current interaction being built.\n*/\nimport { EventEmitter } from '@angular/core';\nimport { Interaction } from '../models/interaction';\nimport { Transition } from '../models/transition';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas-manager.service\";\nexport class InteractionManagerService {\n  constructor(canvasManager) {\n    this.canvasManager = canvasManager;\n    this.interaction = new Interaction();\n    this.isAddingGroup = false;\n    this.addingTransition = 0;\n    this.currentMicroType = '';\n    this.getUpdatedInteraction = new EventEmitter();\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n  /* Group related CRUD functions */\n\n  /*\n  addGroup(x: number, y: number): Group {\n       let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n       let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n       this.interaction.groupIdCounter++;\n       this.interaction.groups.push(g);\n       this.getUpdatedInteraction.emit(this.interaction);\n       return g;\n  }\n     getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n       if (g) {\n      return g;\n    }\n    return undefined;\n  }\n     updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n       gs.push(group);\n       this.interaction.groups = gs;\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n     removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n       this.interaction.transitions = ts;\n       // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n       this.interaction.groups = gs;\n       if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n\n  updateMicro(micro) {\n    let ms = this.interaction.micros.filter(x => x.id != micro.id);\n    ms.push(micro);\n    this.interaction.micros = ms;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  getMicroById(mid) {\n    let m = this.interaction.micros.find(x => x.id === mid);\n    return m;\n  }\n\n  addMicro(x, y) {\n    /*\n    let trackedMicroTypes: MicroType[] = getTrackedMicroTypes();\n         const g: Group | undefined = this.interaction.getGroup(groupId);\n         if (!g) {\n      console.log(\"ERROR: add micro to group failure with groupId: %d\", groupId);\n      return null;\n    }\n         let params: Parameter[] = [];\n         let mt: MicroType | undefined = trackedMicroTypes.find((m: MicroType) => m.type === this.currentMicroType);\n         if (mt) {\n      params = mt.parameters;\n    }\n         let m: MicroInteraction = new MicroInteraction(g.microIdCounter++, g.id, this.currentMicroType, params);\n         g.micros.push(m);\n         this.getUpdatedInteraction.emit(this.interaction);\n         return m;\n    */\n    return null;\n  }\n\n  removeMicro(microId) {\n    // Remove transitions associated with the microId\n    let ts = this.interaction.transitions.filter(x => x.firstMicroId != microId && x.secondMicroId != microId);\n    this.interaction.transitions = ts; // Remove the micro from the micros list\n\n    let ms = this.interaction.micros.filter(x => x.id != microId);\n    this.interaction.micros = ms;\n\n    if (this.interaction.micros.length == 0) {\n      this.interaction.microIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* Parameter related CRUD functions */\n\n\n  updateParams(microId, paramRes) {\n    let m = this.interaction.micros.find(micro => micro.id === microId);\n\n    if (m) {\n      m.updateResults(paramRes);\n      this.getUpdatedInteraction.emit(this.interaction);\n    }\n  }\n  /* Transition related CRUD functions */\n\n\n  removeTransition(tid) {\n    let ts = this.interaction.transitions.filter(x => x.id != tid);\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setFirstMicroId(mid) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstMicroId = mid;\n    this.addingTransition++;\n  }\n\n  setSecondMicroId(mid) {\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find(t => t.firstMicroId == this.currentTransition.firstMicroId && t.secondMicroId == mid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondMicroId = mid;\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n    this.interaction.transitions.push(this.currentTransition);\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition) {\n    let ts = this.interaction.transitions.filter(x => x.id != transition.id);\n    ts.push(transition);\n    this.interaction.transitions = ts;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* State management for view reflection */\n\n\n  setAddingGroup(val) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n    this.canvasManager.updateBtnState.emit();\n  }\n  /* Loading from file on disk */\n\n\n  loadInteractionFromJSONFile(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let t = yield file.text();\n      _this.interaction = new Interaction(t);\n\n      _this.getUpdatedInteraction.emit(_this.interaction);\n    })();\n  }\n  /* Save and load interaction from local storage */\n\n\n  loadInteractionFromLocal() {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n  /* New interaction */\n\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.saveInteractionToLocal();\n  }\n\n}\n\nInteractionManagerService.ɵfac = function InteractionManagerService_Factory(t) {\n  return new (t || InteractionManagerService)(i0.ɵɵinject(i1.CanvasManagerService));\n};\n\nInteractionManagerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InteractionManagerService,\n  factory: InteractionManagerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["EventEmitter","Interaction","Transition","InteractionManagerService","constructor","canvasManager","currentTransition","updateMicro","micro","ms","interaction","micros","filter","x","id","push","getUpdatedInteraction","emit","getMicroById","mid","m","find","addMicro","y","removeMicro","microId","ts","transitions","firstMicroId","secondMicroId","length","microIdCounter","updateParams","paramRes","updateResults","removeTransition","tid","transitionIdCounter","setFirstMicroId","addingTransition","setSecondMicroId","dup","t","undefined","setAddingTransition","updateTransition","transition","setAddingGroup","val","isAddingGroup","updateBtnState","loadInteractionFromJSONFile","file","text","loadInteractionFromLocal","interactionString","localStorage","getItem","saveInteractionToLocal","setItem","JSON","stringify","clearCanvas","i0","factory","providedIn"],"sourceRoot":"","sources":["/home/ubuntu/SocialVerificationWebsite/client/src/app/services/interaction-manager.service.ts"],"sourcesContent":["/*\nThis service manages the current interaction being built.\n*/\n\nimport { EventEmitter, Injectable, Output } from '@angular/core';\nimport { Group } from '../models/group';\nimport { Interaction } from '../models/interaction';\nimport { MicroInteraction } from '../models/microInteraction';\nimport { Parameter } from '../models/parameter';\nimport { MicroType } from '../models/microType';\nimport { ParameterResult } from '../models/parameterResult';\nimport { getTrackedMicroTypes } from '../models/trackedMicroTypes';\nimport { Transition } from '../models/transition';\nimport { CanvasManagerService } from './canvas-manager.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InteractionManagerService {\n\n  interaction: Interaction = new Interaction();\n\n  isAddingGroup: boolean = false;\n  addingTransition: number = 0;\n  currentTransition: Transition;\n\n  currentMicroType: string = '';\n\n  @Output() getUpdatedInteraction: EventEmitter<Interaction> = new EventEmitter<Interaction>();\n\n\n  constructor(\n    private canvasManager: CanvasManagerService\n  ) {\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n\n  /* Group related CRUD functions */\n  \n  /*\n  addGroup(x: number, y: number): Group {\n\n    let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n\n    let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n\n    this.interaction.groupIdCounter++;\n\n    this.interaction.groups.push(g);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return g;\n  }\n\n  getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n\n    if (g) {\n      return g;\n    }\n    return undefined;\n  }\n\n  updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n\n    gs.push(group);\n\n    this.interaction.groups = gs;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n\n    this.interaction.transitions = ts;\n\n    // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n\n    this.interaction.groups = gs;\n\n    if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n  updateMicro(micro: MicroInteraction) {\n    let ms: MicroInteraction[] = this.interaction.micros.filter((x: MicroInteraction) => x.id != micro.id);\n\n    ms.push(micro);\n\n    this.interaction.micros = ms;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  getMicroById(mid: number) {\n    let m: MicroInteraction | undefined = this.interaction.micros.find((x: MicroInteraction) => x.id === mid);\n\n    return m;\n  }\n\n  addMicro(x: number, y: number): MicroInteraction | null {\n\n    /*\n    let trackedMicroTypes: MicroType[] = getTrackedMicroTypes();\n\n    const g: Group | undefined = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: add micro to group failure with groupId: %d\", groupId);\n      return null;\n    }\n\n    let params: Parameter[] = [];\n\n    let mt: MicroType | undefined = trackedMicroTypes.find((m: MicroType) => m.type === this.currentMicroType);\n\n    if (mt) {\n      params = mt.parameters;\n    }\n\n    let m: MicroInteraction = new MicroInteraction(g.microIdCounter++, g.id, this.currentMicroType, params);\n\n    g.micros.push(m);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return m;\n    */\n    return null;\n  }\n\n  removeMicro(microId: number):void {\n\n    // Remove transitions associated with the microId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstMicroId != microId && x.secondMicroId != microId);\n\n    this.interaction.transitions = ts;\n\n    // Remove the micro from the micros list\n    let ms: MicroInteraction[] = this.interaction.micros.filter((x: MicroInteraction) => x.id != microId);\n\n    this.interaction.micros = ms;\n\n    if (this.interaction.micros.length == 0) {\n      this.interaction.microIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Parameter related CRUD functions */\n\n  updateParams(microId: number, paramRes: ParameterResult[]) {\n    let m = this.interaction.micros.find(micro => micro.id === microId);\n\n    if (m) {\n      m.updateResults(paramRes);\n\n      this.getUpdatedInteraction.emit(this.interaction);\n    }\n  }\n\n  /* Transition related CRUD functions */\n\n  removeTransition(tid: number) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != tid);\n\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setFirstMicroId(mid: number) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstMicroId = mid;\n    this.addingTransition++;\n  }\n\n  setSecondMicroId(mid: number) {\n\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find((t: Transition) => t.firstMicroId == this.currentTransition.firstMicroId && t.secondMicroId == mid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondMicroId = mid;\n\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n\n    this.interaction.transitions.push(this.currentTransition);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition: Transition) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != transition.id);\n\n    ts.push(transition);\n\n    this.interaction.transitions = ts;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* State management for view reflection */\n\n  setAddingGroup(val: boolean) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val: number) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  /* Loading from file on disk */\n\n  async loadInteractionFromJSONFile(file: File) {\n    let t: string = await file.text();\n\n    this.interaction = new Interaction(t);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Save and load interaction from local storage */\n\n  loadInteractionFromLocal(): void {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n\n  /* New interaction */\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.saveInteractionToLocal();\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}