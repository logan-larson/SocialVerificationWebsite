{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/SocialVerificationWebsite/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*\nThis service manages the current interaction being built.\n*/\nimport { EventEmitter } from '@angular/core';\nimport { Interaction } from '../models/interaction';\nimport { MicroInteraction } from '../models/microInteraction';\nimport { getTrackedMicroTypes } from '../models/trackedMicroTypes';\nimport { Transition } from '../models/transition';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas-manager.service\";\nexport class InteractionManagerService {\n  constructor(canvasManager) {\n    this.canvasManager = canvasManager;\n    this.interaction = new Interaction();\n    this.isAddingGroup = false;\n    this.addingTransition = 0;\n    this.currentMicroType = '';\n    this.getUpdatedInteraction = new EventEmitter();\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n  /* Group related CRUD functions */\n\n  /*\n  addGroup(x: number, y: number): Group {\n       let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n       let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n       this.interaction.groupIdCounter++;\n       this.interaction.groups.push(g);\n       this.getUpdatedInteraction.emit(this.interaction);\n       return g;\n  }\n     getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n       if (g) {\n      return g;\n    }\n    return undefined;\n  }\n     updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n       gs.push(group);\n       this.interaction.groups = gs;\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n     removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n       this.interaction.transitions = ts;\n       // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n       this.interaction.groups = gs;\n       if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n\n  updateMicro(micro) {\n    let ms = this.interaction.micros.filter(x => x.id != micro.id);\n    ms.push(micro);\n    this.interaction.micros = ms;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  getMicroById(mid) {\n    let m = this.interaction.micros.find(x => x.id === mid);\n    return m;\n  }\n\n  addMicro(x, y) {\n    let trackedMicroTypes = getTrackedMicroTypes();\n    let params = [];\n    let mt = trackedMicroTypes.find(m => m.type === this.currentMicroType);\n\n    if (mt) {\n      params = mt.parameters;\n    }\n\n    let m = new MicroInteraction(this.interaction.microIdCounter++, x, y, this.currentMicroType, params);\n    g.micros.push(m);\n    this.getUpdatedInteraction.emit(this.interaction);\n    return m;\n  }\n\n  removeMicro(microId) {\n    // Remove transitions associated with the microId\n    let ts = this.interaction.transitions.filter(x => x.firstMicroId != microId && x.secondMicroId != microId);\n    this.interaction.transitions = ts; // Remove the micro from the micros list\n\n    let ms = this.interaction.micros.filter(x => x.id != microId);\n    this.interaction.micros = ms;\n\n    if (this.interaction.micros.length == 0) {\n      this.interaction.microIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* Parameter related CRUD functions */\n\n\n  updateParams(microId, paramRes) {\n    let m = this.interaction.micros.find(micro => micro.id === microId);\n\n    if (m) {\n      m.updateResults(paramRes);\n      this.getUpdatedInteraction.emit(this.interaction);\n    }\n  }\n  /* Transition related CRUD functions */\n\n\n  removeTransition(tid) {\n    let ts = this.interaction.transitions.filter(x => x.id != tid);\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setFirstMicroId(mid) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstMicroId = mid;\n    this.addingTransition++;\n  }\n\n  setSecondMicroId(mid) {\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find(t => t.firstMicroId == this.currentTransition.firstMicroId && t.secondMicroId == mid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondMicroId = mid;\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n    this.interaction.transitions.push(this.currentTransition);\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition) {\n    let ts = this.interaction.transitions.filter(x => x.id != transition.id);\n    ts.push(transition);\n    this.interaction.transitions = ts;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* State management for view reflection */\n\n\n  setAddingGroup(val) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n    this.canvasManager.updateBtnState.emit();\n  }\n  /* Loading from file on disk */\n\n\n  loadInteractionFromJSONFile(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let t = yield file.text();\n      _this.interaction = new Interaction(t);\n\n      _this.getUpdatedInteraction.emit(_this.interaction);\n    })();\n  }\n  /* Save and load interaction from local storage */\n\n\n  loadInteractionFromLocal() {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n  /* New interaction */\n\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.saveInteractionToLocal();\n  }\n\n}\n\nInteractionManagerService.ɵfac = function InteractionManagerService_Factory(t) {\n  return new (t || InteractionManagerService)(i0.ɵɵinject(i1.CanvasManagerService));\n};\n\nInteractionManagerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InteractionManagerService,\n  factory: InteractionManagerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["EventEmitter","Interaction","MicroInteraction","getTrackedMicroTypes","Transition","InteractionManagerService","constructor","canvasManager","currentTransition","updateMicro","micro","ms","interaction","micros","filter","x","id","push","getUpdatedInteraction","emit","getMicroById","mid","m","find","addMicro","y","trackedMicroTypes","params","mt","type","currentMicroType","parameters","microIdCounter","g","removeMicro","microId","ts","transitions","firstMicroId","secondMicroId","length","updateParams","paramRes","updateResults","removeTransition","tid","transitionIdCounter","setFirstMicroId","addingTransition","setSecondMicroId","dup","t","undefined","setAddingTransition","updateTransition","transition","setAddingGroup","val","isAddingGroup","updateBtnState","loadInteractionFromJSONFile","file","text","loadInteractionFromLocal","interactionString","localStorage","getItem","saveInteractionToLocal","setItem","JSON","stringify","clearCanvas","i0","factory","providedIn"],"sourceRoot":"","sources":["/home/ubuntu/SocialVerificationWebsite/client/src/app/services/interaction-manager.service.ts"],"sourcesContent":["/*\nThis service manages the current interaction being built.\n*/\n\nimport { EventEmitter, Injectable, Output } from '@angular/core';\nimport { Group } from '../models/group';\nimport { Interaction } from '../models/interaction';\nimport { MicroInteraction } from '../models/microInteraction';\nimport { Parameter } from '../models/parameter';\nimport { MicroType } from '../models/microType';\nimport { ParameterResult } from '../models/parameterResult';\nimport { getTrackedMicroTypes } from '../models/trackedMicroTypes';\nimport { Transition } from '../models/transition';\nimport { CanvasManagerService } from './canvas-manager.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InteractionManagerService {\n\n  interaction: Interaction = new Interaction();\n\n  isAddingGroup: boolean = false;\n  addingTransition: number = 0;\n  currentTransition: Transition;\n\n  currentMicroType: string = '';\n\n  @Output() getUpdatedInteraction: EventEmitter<Interaction> = new EventEmitter<Interaction>();\n\n\n  constructor(\n    private canvasManager: CanvasManagerService\n  ) {\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n\n  /* Group related CRUD functions */\n  \n  /*\n  addGroup(x: number, y: number): Group {\n\n    let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n\n    let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n\n    this.interaction.groupIdCounter++;\n\n    this.interaction.groups.push(g);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return g;\n  }\n\n  getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n\n    if (g) {\n      return g;\n    }\n    return undefined;\n  }\n\n  updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n\n    gs.push(group);\n\n    this.interaction.groups = gs;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n\n    this.interaction.transitions = ts;\n\n    // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n\n    this.interaction.groups = gs;\n\n    if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n  updateMicro(micro: MicroInteraction) {\n    let ms: MicroInteraction[] = this.interaction.micros.filter((x: MicroInteraction) => x.id != micro.id);\n\n    ms.push(micro);\n\n    this.interaction.micros = ms;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  getMicroById(mid: number) {\n    let m: MicroInteraction | undefined = this.interaction.micros.find((x: MicroInteraction) => x.id === mid);\n\n    return m;\n  }\n\n  addMicro(x: number, y: number): MicroInteraction | null {\n\n    let trackedMicroTypes: MicroType[] = getTrackedMicroTypes();\n\n    let params: Parameter[] = [];\n\n    let mt: MicroType | undefined = trackedMicroTypes.find((m: MicroType) => m.type === this.currentMicroType);\n\n    if (mt) {\n      params = mt.parameters;\n    }\n\n    let m: MicroInteraction = new MicroInteraction(this.interaction.microIdCounter++, x, y, this.currentMicroType, params);\n\n    g.micros.push(m);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return m;\n  }\n\n  removeMicro(microId: number):void {\n\n    // Remove transitions associated with the microId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstMicroId != microId && x.secondMicroId != microId);\n\n    this.interaction.transitions = ts;\n\n    // Remove the micro from the micros list\n    let ms: MicroInteraction[] = this.interaction.micros.filter((x: MicroInteraction) => x.id != microId);\n\n    this.interaction.micros = ms;\n\n    if (this.interaction.micros.length == 0) {\n      this.interaction.microIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Parameter related CRUD functions */\n\n  updateParams(microId: number, paramRes: ParameterResult[]) {\n    let m = this.interaction.micros.find(micro => micro.id === microId);\n\n    if (m) {\n      m.updateResults(paramRes);\n\n      this.getUpdatedInteraction.emit(this.interaction);\n    }\n  }\n\n  /* Transition related CRUD functions */\n\n  removeTransition(tid: number) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != tid);\n\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setFirstMicroId(mid: number) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstMicroId = mid;\n    this.addingTransition++;\n  }\n\n  setSecondMicroId(mid: number) {\n\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find((t: Transition) => t.firstMicroId == this.currentTransition.firstMicroId && t.secondMicroId == mid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondMicroId = mid;\n\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n\n    this.interaction.transitions.push(this.currentTransition);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition: Transition) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != transition.id);\n\n    ts.push(transition);\n\n    this.interaction.transitions = ts;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* State management for view reflection */\n\n  setAddingGroup(val: boolean) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val: number) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  /* Loading from file on disk */\n\n  async loadInteractionFromJSONFile(file: File) {\n    let t: string = await file.text();\n\n    this.interaction = new Interaction(t);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Save and load interaction from local storage */\n\n  loadInteractionFromLocal(): void {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n\n  /* New interaction */\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.saveInteractionToLocal();\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}