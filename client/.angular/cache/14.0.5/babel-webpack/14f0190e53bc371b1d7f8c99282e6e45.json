{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/SocialVerificationWebsite/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*\nThis service manages the current interaction being built.\n*/\nimport { EventEmitter } from '@angular/core';\nimport { Interaction } from '../models/interaction';\nimport { MicroInteraction } from '../models/microInteraction';\nimport { getTrackedMicroTypes } from '../models/trackedMicroTypes';\nimport { Transition } from '../models/transition';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas-manager.service\";\nexport class InteractionManagerService {\n  constructor(canvasManager) {\n    this.canvasManager = canvasManager;\n    this.interaction = new Interaction();\n    this.isAddingGroup = false;\n    this.addingTransition = 0;\n    this.currentMicroType = '';\n    this.getUpdatedInteraction = new EventEmitter();\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n  /* Group related CRUD functions */\n\n  /*\n  addGroup(x: number, y: number): Group {\n       let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n       let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n       this.interaction.groupIdCounter++;\n       this.interaction.groups.push(g);\n       this.getUpdatedInteraction.emit(this.interaction);\n       return g;\n  }\n     getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n       if (g) {\n      return g;\n    }\n    return undefined;\n  }\n     updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n       gs.push(group);\n       this.interaction.groups = gs;\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n     removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n       this.interaction.transitions = ts;\n       // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n       this.interaction.groups = gs;\n       if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n\n  updateMicro(micro) {\n    let ms = this.interaction.micros.filter(x => x.id != micro.id);\n    ms.push(micro);\n    this.interaction.micros = ms;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  addMicroToGroup(groupId) {\n    let trackedMicroTypes = getTrackedMicroTypes();\n    const g = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: add micro to group failure with groupId: %d\", groupId);\n      return null;\n    }\n\n    let params = [];\n    let mt = trackedMicroTypes.find(m => m.type === this.currentMicroType);\n\n    if (mt) {\n      params = mt.parameters;\n    }\n\n    let m = new MicroInteraction(g.microIdCounter++, g.id, this.currentMicroType, params);\n    g.micros.push(m);\n    this.getUpdatedInteraction.emit(this.interaction);\n    return m;\n  }\n\n  removeMicro(groupId, microId) {\n    const g = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: remove micro failure with groupId: %d\", groupId);\n      return;\n    }\n\n    g.removeMicro(microId);\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* Parameter related CRUD functions */\n\n\n  updateParams(groupId, microId, paramRes) {\n    let g = this.interaction.groups.find(group => group.id === groupId);\n\n    if (g) {\n      let m = g.micros.find(micro => micro.id === microId);\n\n      if (m) {\n        m.updateResults(paramRes);\n        this.getUpdatedInteraction.emit(this.interaction);\n      }\n    }\n  }\n  /* Transition related CRUD functions */\n\n\n  removeTransition(tid) {\n    let ts = this.interaction.transitions.filter(x => x.id != tid);\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setGroup1Id(gid) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstGroupId = gid;\n    this.addingTransition++;\n  }\n\n  setGroup2Id(gid) {\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find(t => t.firstGroupId == this.currentTransition.firstGroupId && t.secondGroupId == gid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondGroupId = gid;\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n    this.interaction.transitions.push(this.currentTransition);\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition) {\n    let ts = this.interaction.transitions.filter(x => x.id != transition.id);\n    ts.push(transition);\n    this.interaction.transitions = ts;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* State management for view reflection */\n\n\n  setAddingGroup(val) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n    this.canvasManager.updateBtnState.emit();\n  }\n  /* Loading from file on disk */\n\n\n  loadInteractionFromJSONFile(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let t = yield file.text();\n      _this.interaction = new Interaction(t);\n\n      _this.getUpdatedInteraction.emit(_this.interaction);\n    })();\n  }\n  /* Save and load interaction from local storage */\n\n\n  loadInteractionFromLocal() {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n  /* New interaction */\n\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.saveInteractionToLocal();\n  }\n\n}\n\nInteractionManagerService.ɵfac = function InteractionManagerService_Factory(t) {\n  return new (t || InteractionManagerService)(i0.ɵɵinject(i1.CanvasManagerService));\n};\n\nInteractionManagerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InteractionManagerService,\n  factory: InteractionManagerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["EventEmitter","Interaction","MicroInteraction","getTrackedMicroTypes","Transition","InteractionManagerService","constructor","canvasManager","currentTransition","updateMicro","micro","ms","interaction","micros","filter","x","id","push","getUpdatedInteraction","emit","addMicroToGroup","groupId","trackedMicroTypes","g","getGroup","console","log","params","mt","find","m","type","currentMicroType","parameters","microIdCounter","removeMicro","microId","updateParams","paramRes","groups","group","updateResults","removeTransition","tid","ts","transitions","length","transitionIdCounter","setGroup1Id","gid","firstGroupId","addingTransition","setGroup2Id","dup","t","secondGroupId","undefined","setAddingTransition","updateTransition","transition","setAddingGroup","val","isAddingGroup","updateBtnState","loadInteractionFromJSONFile","file","text","loadInteractionFromLocal","interactionString","localStorage","getItem","saveInteractionToLocal","setItem","JSON","stringify","clearCanvas","i0","factory","providedIn"],"sourceRoot":"","sources":["/home/ubuntu/SocialVerificationWebsite/client/src/app/services/interaction-manager.service.ts"],"sourcesContent":["/*\nThis service manages the current interaction being built.\n*/\n\nimport { EventEmitter, Injectable, Output } from '@angular/core';\nimport { Group } from '../models/group';\nimport { Interaction } from '../models/interaction';\nimport { MicroInteraction } from '../models/microInteraction';\nimport { Parameter } from '../models/parameter';\nimport { MicroType } from '../models/microType';\nimport { ParameterResult } from '../models/parameterResult';\nimport { getTrackedMicroTypes } from '../models/trackedMicroTypes';\nimport { Transition } from '../models/transition';\nimport { CanvasManagerService } from './canvas-manager.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InteractionManagerService {\n\n  interaction: Interaction = new Interaction();\n\n  isAddingGroup: boolean = false;\n  addingTransition: number = 0;\n  currentTransition: Transition;\n\n  currentMicroType: string = '';\n\n  @Output() getUpdatedInteraction: EventEmitter<Interaction> = new EventEmitter<Interaction>();\n\n\n  constructor(\n    private canvasManager: CanvasManagerService\n  ) {\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n\n  /* Group related CRUD functions */\n  \n  /*\n  addGroup(x: number, y: number): Group {\n\n    let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n\n    let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n\n    this.interaction.groupIdCounter++;\n\n    this.interaction.groups.push(g);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return g;\n  }\n\n  getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n\n    if (g) {\n      return g;\n    }\n    return undefined;\n  }\n\n  updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n\n    gs.push(group);\n\n    this.interaction.groups = gs;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n\n    this.interaction.transitions = ts;\n\n    // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n\n    this.interaction.groups = gs;\n\n    if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n  updateMicro(micro: MicroInteraction) {\n    let ms: MicroInteraction[] = this.interaction.micros.filter((x: MicroInteraction) => x.id != micro.id);\n\n    ms.push(micro);\n\n    this.interaction.micros = ms;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  addMicroToGroup(groupId: number): MicroInteraction  | null {\n\n    let trackedMicroTypes: MicroType[] = getTrackedMicroTypes();\n\n    const g: Group | undefined = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: add micro to group failure with groupId: %d\", groupId);\n      return null;\n    }\n\n    let params: Parameter[] = [];\n\n    let mt: MicroType | undefined = trackedMicroTypes.find((m: MicroType) => m.type === this.currentMicroType);\n\n    if (mt) {\n      params = mt.parameters;\n    }\n\n    let m: MicroInteraction = new MicroInteraction(g.microIdCounter++, g.id, this.currentMicroType, params);\n\n    g.micros.push(m);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return m;\n  }\n\n  removeMicro(groupId: number, microId: number):void {\n    const g: Group | undefined = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: remove micro failure with groupId: %d\", groupId);\n      return;\n    }\n\n    g.removeMicro(microId);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Parameter related CRUD functions */\n\n  updateParams(groupId: number, microId: number, paramRes: ParameterResult[]) {\n    let g = this.interaction.groups.find(group => group.id === groupId);\n\n    if (g) {\n      let m = g.micros.find(micro => micro.id === microId);\n      if (m) {\n        m.updateResults(paramRes);\n\n        this.getUpdatedInteraction.emit(this.interaction);\n      }\n    }\n  }\n\n  /* Transition related CRUD functions */\n\n  removeTransition(tid: number) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != tid);\n\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setGroup1Id(gid: number) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstGroupId = gid;\n    this.addingTransition++;\n  }\n\n  setGroup2Id(gid: number) {\n\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find((t: Transition) => t.firstGroupId == this.currentTransition.firstGroupId && t.secondGroupId == gid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondGroupId = gid;\n\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n\n    this.interaction.transitions.push(this.currentTransition);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition: Transition) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != transition.id);\n\n    ts.push(transition);\n\n    this.interaction.transitions = ts;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* State management for view reflection */\n\n  setAddingGroup(val: boolean) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val: number) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  /* Loading from file on disk */\n\n  async loadInteractionFromJSONFile(file: File) {\n    let t: string = await file.text();\n\n    this.interaction = new Interaction(t);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Save and load interaction from local storage */\n\n  loadInteractionFromLocal(): void {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n\n  /* New interaction */\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.saveInteractionToLocal();\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}