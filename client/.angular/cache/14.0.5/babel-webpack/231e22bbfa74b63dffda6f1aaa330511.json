{"ast":null,"code":"import _asyncToGenerator from \"/home/ubuntu/SocialVerificationWebsite/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n\n/*\nThis service manages the current interaction being built.\n*/\nimport { EventEmitter } from '@angular/core';\nimport { Interaction } from '../models/interaction';\nimport { Transition } from '../models/transition';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./canvas-manager.service\";\nexport class InteractionManagerService {\n  constructor(canvasManager) {\n    this.canvasManager = canvasManager;\n    this.interaction = new Interaction();\n    this.isAddingGroup = false;\n    this.addingTransition = 0;\n    this.currentMicroType = '';\n    this.getUpdatedInteraction = new EventEmitter();\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n  /* Group related CRUD functions */\n\n  /*\n  addGroup(x: number, y: number): Group {\n       let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n       let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n       this.interaction.groupIdCounter++;\n       this.interaction.groups.push(g);\n       this.getUpdatedInteraction.emit(this.interaction);\n       return g;\n  }\n     getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n       if (g) {\n      return g;\n    }\n    return undefined;\n  }\n     updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n       gs.push(group);\n       this.interaction.groups = gs;\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n     removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n       this.interaction.transitions = ts;\n       // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n       this.interaction.groups = gs;\n       if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n\n  updateMicro(micro) {\n    let ms = this.interaction.micros.filter(x => x.id != micro.id);\n    ms.push(micro);\n    this.interaction.micros = ms;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /*\n  addMicroToGroup(groupId: number): MicroInteraction  | null {\n       let trackedMicroTypes: MicroType[] = getTrackedMicroTypes();\n       const g: Group | undefined = this.interaction.getGroup(groupId);\n       if (!g) {\n      console.log(\"ERROR: add micro to group failure with groupId: %d\", groupId);\n      return null;\n    }\n       let params: Parameter[] = [];\n       let mt: MicroType | undefined = trackedMicroTypes.find((m: MicroType) => m.type === this.currentMicroType);\n       if (mt) {\n      params = mt.parameters;\n    }\n       let m: MicroInteraction = new MicroInteraction(g.microIdCounter++, g.id, this.currentMicroType, params);\n       g.micros.push(m);\n       this.getUpdatedInteraction.emit(this.interaction);\n       return m;\n  }\n     removeMicro(groupId: number, microId: number):void {\n    const g: Group | undefined = this.interaction.getGroup(groupId);\n       if (!g) {\n      console.log(\"ERROR: remove micro failure with groupId: %d\", groupId);\n      return;\n    }\n       g.removeMicro(microId);\n       this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Parameter related CRUD functions */\n\n\n  updateParams(microId, paramRes) {\n    let m = this.interaction.micros.find(micro => micro.id === microId);\n\n    if (m) {\n      m.updateResults(paramRes);\n      this.getUpdatedInteraction.emit(this.interaction);\n    }\n  }\n  /* Transition related CRUD functions */\n\n\n  removeTransition(tid) {\n    let ts = this.interaction.transitions.filter(x => x.id != tid);\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setGroup1Id(gid) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstGroupId = gid;\n    this.addingTransition++;\n  }\n\n  setGroup2Id(gid) {\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find(t => t.firstGroupId == this.currentTransition.firstGroupId && t.secondGroupId == gid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondGroupId = gid;\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n    this.interaction.transitions.push(this.currentTransition);\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition) {\n    let ts = this.interaction.transitions.filter(x => x.id != transition.id);\n    ts.push(transition);\n    this.interaction.transitions = ts;\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  /* State management for view reflection */\n\n\n  setAddingGroup(val) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n    this.canvasManager.updateBtnState.emit();\n  }\n  /* Loading from file on disk */\n\n\n  loadInteractionFromJSONFile(file) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let t = yield file.text();\n      _this.interaction = new Interaction(t);\n\n      _this.getUpdatedInteraction.emit(_this.interaction);\n    })();\n  }\n  /* Save and load interaction from local storage */\n\n\n  loadInteractionFromLocal() {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n  /* New interaction */\n\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n    this.getUpdatedInteraction.emit(this.interaction);\n    this.saveInteractionToLocal();\n  }\n\n}\n\nInteractionManagerService.ɵfac = function InteractionManagerService_Factory(t) {\n  return new (t || InteractionManagerService)(i0.ɵɵinject(i1.CanvasManagerService));\n};\n\nInteractionManagerService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InteractionManagerService,\n  factory: InteractionManagerService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";;AAAA;;;AAIA,SAASA,YAAT,QAAiD,eAAjD;AAEA,SAASC,WAAT,QAA4B,uBAA5B;AAMA,SAASC,UAAT,QAA2B,sBAA3B;;;AAMA,OAAM,MAAOC,yBAAP,CAAgC;EAapCC,YACUC,aADV,EAC6C;IAAnC;IAZV,mBAA2B,IAAIJ,WAAJ,EAA3B;IAEA,qBAAyB,KAAzB;IACA,wBAA2B,CAA3B;IAGA,wBAA2B,EAA3B;IAEU,6BAAmD,IAAID,YAAJ,EAAnD;IAMR,KAAKM,iBAAL,GAAyB,IAAIJ,UAAJ,CAAe,CAAC,CAAhB,EAAmB,CAAC,CAApB,EAAuB,CAAC,CAAxB,CAAzB;EACD;EAED;;EAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuDA;;;EAEAK,WAAW,CAACC,KAAD,EAAwB;IACjC,IAAIC,EAAE,GAAuB,KAAKC,WAAL,CAAiBC,MAAjB,CAAwBC,MAAxB,CAAgCC,CAAD,IAAyBA,CAAC,CAACC,EAAF,IAAQN,KAAK,CAACM,EAAtE,CAA7B;IAEAL,EAAE,CAACM,IAAH,CAAQP,KAAR;IAEA,KAAKE,WAAL,CAAiBC,MAAjB,GAA0BF,EAA1B;IAEA,KAAKO,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;EACD;EAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA2CA;;;EAEAQ,YAAY,CAACC,OAAD,EAAkBC,QAAlB,EAA6C;IACvD,IAAIC,CAAC,GAAG,KAAKX,WAAL,CAAiBC,MAAjB,CAAwBW,IAAxB,CAA6Bd,KAAK,IAAIA,KAAK,CAACM,EAAN,KAAaK,OAAnD,CAAR;;IAEA,IAAIE,CAAJ,EAAO;MACLA,CAAC,CAACE,aAAF,CAAgBH,QAAhB;MAEA,KAAKJ,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;IACD;EACF;EAED;;;EAEAc,gBAAgB,CAACC,GAAD,EAAY;IAC1B,IAAIC,EAAE,GAAiB,KAAKhB,WAAL,CAAiBiB,WAAjB,CAA6Bf,MAA7B,CAAqCC,CAAD,IAAmBA,CAAC,CAACC,EAAF,IAAQW,GAA/D,CAAvB;IAEA,KAAKf,WAAL,CAAiBiB,WAAjB,GAA+BD,EAA/B;;IAEA,IAAI,KAAKhB,WAAL,CAAiBiB,WAAjB,CAA6BC,MAA7B,IAAuC,CAA3C,EAA8C;MAC5C,KAAKlB,WAAL,CAAiBmB,mBAAjB,GAAuC,CAAvC;IACD;;IAED,KAAKb,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;EACD;;EAEDoB,WAAW,CAACC,GAAD,EAAY;IACrB,KAAKzB,iBAAL,GAAyB,IAAIJ,UAAJ,EAAzB;IACA,KAAKI,iBAAL,CAAuB0B,YAAvB,GAAsCD,GAAtC;IACA,KAAKE,gBAAL;EACD;;EAEDC,WAAW,CAACH,GAAD,EAAY;IAErB;IACA,IAAII,GAAG,GAAG,KAAKzB,WAAL,CAAiBiB,WAAjB,CAA6BL,IAA7B,CAAmCc,CAAD,IAAmBA,CAAC,CAACJ,YAAF,IAAkB,KAAK1B,iBAAL,CAAuB0B,YAAzC,IAAyDI,CAAC,CAACC,aAAF,IAAmBN,GAAjI,CAAV;;IAEA,IAAII,GAAG,IAAIG,SAAX,EAAsB;MACpB;IACD;;IAED,KAAKhC,iBAAL,CAAuB+B,aAAvB,GAAuCN,GAAvC;IAEA,KAAKzB,iBAAL,CAAuBQ,EAAvB,GAA4B,KAAKJ,WAAL,CAAiBmB,mBAA7C;IACA,KAAKnB,WAAL,CAAiBmB,mBAAjB;IAEA,KAAKnB,WAAL,CAAiBiB,WAAjB,CAA6BZ,IAA7B,CAAkC,KAAKT,iBAAvC;IAEA,KAAKU,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;IAEA,KAAK6B,mBAAL,CAAyB,CAAzB;EACD;;EAEDC,gBAAgB,CAACC,UAAD,EAAuB;IACrC,IAAIf,EAAE,GAAiB,KAAKhB,WAAL,CAAiBiB,WAAjB,CAA6Bf,MAA7B,CAAqCC,CAAD,IAAmBA,CAAC,CAACC,EAAF,IAAQ2B,UAAU,CAAC3B,EAA1E,CAAvB;IAEAY,EAAE,CAACX,IAAH,CAAQ0B,UAAR;IAEA,KAAK/B,WAAL,CAAiBiB,WAAjB,GAA+BD,EAA/B;IAEA,KAAKV,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;EACD;EAED;;;EAEAgC,cAAc,CAACC,GAAD,EAAa;IACzB,KAAKC,aAAL,GAAqBD,GAArB;IACA,KAAKV,gBAAL,GAAwB,CAAxB;IAEA,KAAK5B,aAAL,CAAmBwC,cAAnB,CAAkC5B,IAAlC;EACD;;EAEDsB,mBAAmB,CAACI,GAAD,EAAY;IAC7B,KAAKV,gBAAL,GAAwBU,GAAxB;IACA,KAAKC,aAAL,GAAqB,KAArB;IAEA,KAAKvC,aAAL,CAAmBwC,cAAnB,CAAkC5B,IAAlC;EACD;EAED;;;EAEM6B,2BAA2B,CAACC,IAAD,EAAW;IAAA;;IAAA;MAC1C,IAAIX,CAAC,SAAiBW,IAAI,CAACC,IAAL,EAAtB;MAEA,KAAI,CAACtC,WAAL,GAAmB,IAAIT,WAAJ,CAAgBmC,CAAhB,CAAnB;;MAEA,KAAI,CAACpB,qBAAL,CAA2BC,IAA3B,CAAgC,KAAI,CAACP,WAArC;IAL0C;EAM3C;EAED;;;EAEAuC,wBAAwB;IACtB,IAAIC,iBAAiB,GAAGC,YAAY,CAACC,OAAb,CAAqB,aAArB,CAAxB;;IAEA,IAAIF,iBAAJ,EAAuB;MACrB,KAAKxC,WAAL,GAAmB,IAAIT,WAAJ,CAAgBiD,iBAAhB,CAAnB;IACD,CAFD,MAEO;MACL,KAAKxC,WAAL,GAAmB,IAAIT,WAAJ,EAAnB;IACD;;IAED,KAAKe,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;EACD;;EAED2C,sBAAsB;IACpBF,YAAY,CAACG,OAAb,CAAqB,aAArB,EAAoCC,IAAI,CAACC,SAAL,CAAe,KAAK9C,WAApB,CAApC;EACD;EAED;;;EAEA+C,WAAW;IACT,KAAK/C,WAAL,GAAmB,IAAIT,WAAJ,EAAnB;IAEA,KAAKe,qBAAL,CAA2BC,IAA3B,CAAgC,KAAKP,WAArC;IAEA,KAAK2C,sBAAL;EACD;;AAtPmC;;;mBAAzBlD,2BAAyBuD;AAAA;;;SAAzBvD;EAAyBwD,SAAzBxD,yBAAyB;EAAAyD,YAFxB","names":["EventEmitter","Interaction","Transition","InteractionManagerService","constructor","canvasManager","currentTransition","updateMicro","micro","ms","interaction","micros","filter","x","id","push","getUpdatedInteraction","emit","updateParams","microId","paramRes","m","find","updateResults","removeTransition","tid","ts","transitions","length","transitionIdCounter","setGroup1Id","gid","firstGroupId","addingTransition","setGroup2Id","dup","t","secondGroupId","undefined","setAddingTransition","updateTransition","transition","setAddingGroup","val","isAddingGroup","updateBtnState","loadInteractionFromJSONFile","file","text","loadInteractionFromLocal","interactionString","localStorage","getItem","saveInteractionToLocal","setItem","JSON","stringify","clearCanvas","i0","factory","providedIn"],"sourceRoot":"","sources":["/home/ubuntu/SocialVerificationWebsite/client/src/app/services/interaction-manager.service.ts"],"sourcesContent":["/*\nThis service manages the current interaction being built.\n*/\n\nimport { EventEmitter, Injectable, Output } from '@angular/core';\nimport { Group } from '../models/group';\nimport { Interaction } from '../models/interaction';\nimport { MicroInteraction } from '../models/microInteraction';\nimport { Parameter } from '../models/parameter';\nimport { MicroType } from '../models/microType';\nimport { ParameterResult } from '../models/parameterResult';\nimport { getTrackedMicroTypes } from '../models/trackedMicroTypes';\nimport { Transition } from '../models/transition';\nimport { CanvasManagerService } from './canvas-manager.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InteractionManagerService {\n\n  interaction: Interaction = new Interaction();\n\n  isAddingGroup: boolean = false;\n  addingTransition: number = 0;\n  currentTransition: Transition;\n\n  currentMicroType: string = '';\n\n  @Output() getUpdatedInteraction: EventEmitter<Interaction> = new EventEmitter<Interaction>();\n\n\n  constructor(\n    private canvasManager: CanvasManagerService\n  ) {\n    this.currentTransition = new Transition(-1, -1, -1);\n  }\n\n  /* Group related CRUD functions */\n  \n  /*\n  addGroup(x: number, y: number): Group {\n\n    let isInitial: boolean = this.interaction.groupIdCounter == 0 ? true : false;\n    let name: string = 'untitled' + this.interaction.groupIdCounter;\n\n    let g = new Group(isInitial, this.interaction.groupIdCounter, name, x + this.canvasManager.canvasScrollOffset.x, y + this.canvasManager.canvasScrollOffset.y);\n\n    this.interaction.groupIdCounter++;\n\n    this.interaction.groups.push(g);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return g;\n  }\n\n  getGroupById(id: number): Group | undefined {\n    let g: Group | undefined = this.interaction.groups.find((x: Group) => x.id === id);\n\n    if (g) {\n      return g;\n    }\n    return undefined;\n  }\n\n  updateGroup(group: Group) {\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != group.id);\n\n    gs.push(group);\n\n    this.interaction.groups = gs;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  removeGroup(groupId: number):void {\n    // Remove transitions associated with the groupId\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.firstGroupId != groupId && x.secondGroupId != groupId);\n\n    this.interaction.transitions = ts;\n\n    // Remove the group from the groups list\n    let gs: Group[] = this.interaction.groups.filter((x: Group) => x.id != groupId);\n\n    this.interaction.groups = gs;\n\n    if (this.interaction.groups.length == 0) {\n      this.interaction.groupIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Micro related CRUD functions */\n\n  updateMicro(micro: MicroInteraction) {\n    let ms: MicroInteraction[] = this.interaction.micros.filter((x: MicroInteraction) => x.id != micro.id);\n\n    ms.push(micro);\n\n    this.interaction.micros = ms;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /*\n  addMicroToGroup(groupId: number): MicroInteraction  | null {\n\n    let trackedMicroTypes: MicroType[] = getTrackedMicroTypes();\n\n    const g: Group | undefined = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: add micro to group failure with groupId: %d\", groupId);\n      return null;\n    }\n\n    let params: Parameter[] = [];\n\n    let mt: MicroType | undefined = trackedMicroTypes.find((m: MicroType) => m.type === this.currentMicroType);\n\n    if (mt) {\n      params = mt.parameters;\n    }\n\n    let m: MicroInteraction = new MicroInteraction(g.microIdCounter++, g.id, this.currentMicroType, params);\n\n    g.micros.push(m);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    return m;\n  }\n\n  removeMicro(groupId: number, microId: number):void {\n    const g: Group | undefined = this.interaction.getGroup(groupId);\n\n    if (!g) {\n      console.log(\"ERROR: remove micro failure with groupId: %d\", groupId);\n      return;\n    }\n\n    g.removeMicro(microId);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n  */\n\n  /* Parameter related CRUD functions */\n\n  updateParams(microId: number, paramRes: ParameterResult[]) {\n    let m = this.interaction.micros.find(micro => micro.id === microId);\n\n    if (m) {\n      m.updateResults(paramRes);\n\n      this.getUpdatedInteraction.emit(this.interaction);\n    }\n  }\n\n  /* Transition related CRUD functions */\n\n  removeTransition(tid: number) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != tid);\n\n    this.interaction.transitions = ts;\n\n    if (this.interaction.transitions.length == 0) {\n      this.interaction.transitionIdCounter = 0;\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  setGroup1Id(gid: number) {\n    this.currentTransition = new Transition();\n    this.currentTransition.firstGroupId = gid;\n    this.addingTransition++;\n  }\n\n  setGroup2Id(gid: number) {\n\n    // Check that this is going to be a unique transition\n    let dup = this.interaction.transitions.find((t: Transition) => t.firstGroupId == this.currentTransition.firstGroupId && t.secondGroupId == gid);\n\n    if (dup != undefined) {\n      return;\n    }\n\n    this.currentTransition.secondGroupId = gid;\n\n    this.currentTransition.id = this.interaction.transitionIdCounter;\n    this.interaction.transitionIdCounter++;\n\n    this.interaction.transitions.push(this.currentTransition);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.setAddingTransition(0);\n  }\n\n  updateTransition(transition: Transition) {\n    let ts: Transition[] = this.interaction.transitions.filter((x: Transition) => x.id != transition.id);\n\n    ts.push(transition);\n\n    this.interaction.transitions = ts;\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* State management for view reflection */\n\n  setAddingGroup(val: boolean) {\n    this.isAddingGroup = val;\n    this.addingTransition = 0;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  setAddingTransition(val: number) {\n    this.addingTransition = val;\n    this.isAddingGroup = false;\n\n    this.canvasManager.updateBtnState.emit();\n  }\n\n  /* Loading from file on disk */\n\n  async loadInteractionFromJSONFile(file: File) {\n    let t: string = await file.text();\n\n    this.interaction = new Interaction(t);\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  /* Save and load interaction from local storage */\n\n  loadInteractionFromLocal(): void {\n    let interactionString = localStorage.getItem('interaction');\n\n    if (interactionString) {\n      this.interaction = new Interaction(interactionString);\n    } else {\n      this.interaction = new Interaction();\n    }\n\n    this.getUpdatedInteraction.emit(this.interaction);\n  }\n\n  saveInteractionToLocal() {\n    localStorage.setItem('interaction', JSON.stringify(this.interaction));\n  }\n\n  /* New interaction */\n\n  clearCanvas() {\n    this.interaction = new Interaction();\n\n    this.getUpdatedInteraction.emit(this.interaction);\n\n    this.saveInteractionToLocal();\n  }\n\n}\n"]},"metadata":{},"sourceType":"module"}